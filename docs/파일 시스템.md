# 파일 시스템


컴퓨터의 디스크에 파일을 저장할 때 사용하는 시스템으로 파일 시스템은 곧 저장의 규칙, 저장 방식을 정의한다. 시스템 및 프로그램이 예상하는 것과 저장 방식을 다르게 하면 모든 것이 흐트러진다. 

저장 방식은 매체와 [[파일 포맷]]에 따라 다르다. 

포맷은 저장방식을 설정하는 과정, 파일 시스템을 생성하는 과정이다. 파일시스템의 스펙에 따라, 저장 방식에 따라 최대 저장공간 크기와 파일 최대 크기, 파일 이름 길이가 제한된다.  


## [[리눅스]]의 파일 시스템

리눅스의 파일 시스템에서는 모든 파일이 [[inode]]를 가지고 있다. 

모든 파일은 최상위 디렉토리인 /root 밑에 있으며 특정한 [[디렉토리]]에 종속되어 있다. 

한편 디렉토리는 다른 파일과 마찬가지로 inode를 가진 파일로 해당 디렉토리에 접근 권한(access permission)을 가지고 있다면 디렉토리가 가진 차림표에서 디렉토리에 포함된 파일의 메타 데이터에 접근할 수 있다. 이 메타 데이터에는 다시 inode가 포함되어 있다. 

즉 리눅스 파일 시스템은 계층형 그래프 구조로 파일은 노드이며 폴더도 파일을 가리키는 차림표를 가진 노드이다. 

윈도와 달리 리눅스는 파일이 확장자 대신 [[시그니처]]를 가지고 있다. 
확장자를 사용하는 구조는 어떤 확장자가 어떤 프로그램에 연결되는가를 알기 어려우므로 보안상 위험이 더 크다. 



### 파티셔닝 

특히 파티셔닝 방식은 윈도 시스템과 리눅스 시스템의 가장 큰 차이 중 하나다. 윈도는 [[파티션]]을 나눌 때 [[마운트 포인트]]를 드라이브를 단위로 한다. 그런데 리눅스 시스템은 마운트 포인트를 자주 사용하는 디렉토리로 정한다. 

예컨대 윈도는 마운트 지점이 드라이브 단위이며 목적에 따라 드라이브를 나누지는 않는 편. 해당 드라이브의 용량을 확보하기 위해 파일을 지우는 방식의 습속을 만들어낸다. 즉, 윈도의 경우 파티셔닝 혹은 각 마운팅 포인트의 상태가 아니라 설치된 프로그램 '내용'을 보아야 어떤 목적의 컴퓨터인지 이해가 가능하다.  

반면 리눅스는 마운트 포인트가 디렉토리이므로 목적에 따라 파티션을 디렉토리로 나눌 수 있다. 운영체제가 설치된 구조('형식')만 보고도 무슨 목적으로 사용되는 컴퓨터인지 알 수 있다. 예컨대 호스팅 업체는 자신의 서버를 입주할 공간을 각각의 마운팅 포인트/디렉토리로 파티셔닝 할 수 있다. 이 경우 /home 디렉토리가 아주 많을 것이다.   

파티셔닝 할 때 순서를 잘 정리하면 부팅 속도가 빨라진다. 그러나 현재 SSD 속도에서는 별 의미가 없게 되었다.  
/boot 디렉토리를 제일 먼저 두면 부팅 속도가 빨라진다.  


### LVM
참조: [[LVM]]



## 참조 
- [[저널링 시스템]]


[//begin]: # "Autogenerated link references for markdown compatibility"
[파일 포맷]: <파일 포맷.md> "파일 포맷"
[리눅스]: 리눅스.md "리눅스"
[inode]: inode.md "inode"
[디렉토리]: 디렉토리.md "디렉토리"
[시그니처]: 시그니처.md "시그니처"
[LVM]: LVM.md "LVM"
[저널링 시스템]: <저널링 시스템.md> "저널링 시스템"
[//end]: # "Autogenerated link references"